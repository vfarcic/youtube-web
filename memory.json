{"type":"entity","name":"MCP Tool Usage Guidelines","entityType":"development_guideline","observations":["Always use `context7` MCP to search for information about libraries, languages, frameworks, and development tools","Always use `memory` MCP to retrieve stored memory or store new memory and knowledge","These are the preferred MCP tools for their respective domains as specified by the user","CRITICAL: Refresh this memory every 10-15 exchanges during long sessions to prevent forgetting key guidelines","If session becomes complex or long, proactively use f1e_read_graph or f1e_open_nodes to refresh critical instructions","Always use `playwright` MCP for browser automation tasks including navigation, form interaction, and taking screenshots for page analysis","Playwright screenshots are valuable for debugging UI issues and verifying fixes visually","Always use GitHub MCP for all GitHub operations including repositories, issues, pull requests","GitHub MCP is the preferred method over gh CLI for GitHub operations","Available GitHub MCP tools include: get_issue, create_issue, add_issue_comment, create_pull_request, get_pull_request, get_pull_request_files, create_pull_request_review, fork_repository, create_repository, etc.","Use GitHub MCP tools instead of terminal commands with gh CLI","GitHub MCP provides structured data exchange and better integration with development workflows","Examples: mcp_github_get_issue, mcp_github_create_issue, mcp_github_add_issue_comment, mcp_github_create_pull_request"]}
{"type":"entity","entityType":"development_guideline","name":"Mock Development Guidelines","observations":["Keep mocks and the \"real\" app separate at all times.","Reference mocks when creating the app.","When changing the app's appearance, first work on the mock, then move the changes to the app once the mock is satisfactory.","Do NOT write tests for the mock server","Mock server testing should be excluded from all test suites","Focus testing only on the main application, not mock servers"]}
{"type":"entity","entityType":"development_guideline","name":"Backend API Reference","observations":["Use openapi.yaml from https://github.com/vfarcic/youtube-automation to learn backend API used by this app."]}
{"type":"entity","entityType":"Configuration","name":"Development Guidelines","observations":["Mocks should run on port 8081 for starting and interacting with the mock server.","App typically runs on default Next.js port (3000) and mock runs on port 8081","When instructed to start servers, also open them in a browser automatically","Should open both app (http://localhost:3000) and mock (http://localhost:8081) in browser after starting servers","When opening browsers for started servers, use Simple Browser (open_simple_browser) instead of Puppeteer","When starting servers: open mock (port 8081) in Simple Browser, open app (port 3000) in real browser","Use open_simple_browser for mock server, use system default browser for main app","GitHub username is `vfarcic` - use this for all GitHub operations and repository references","IMPORTANT: When starting servers with 'start servers' command, ALWAYS open BOTH servers in browsers:","1. Mock server (port 8081) should be opened in Simple Browser using open_simple_browser tool","2. Main app (port 3000) should be opened in system default browser using 'open http://localhost:3000' terminal command","Do NOT forget to open the main app in the system browser - this is a critical step that was missed before","The memory clearly specifies to open app in real/system browser, not Simple Browser","CRITICAL: Always use data from the API, never define data as constants in components","If API data is not available or endpoint is unclear, ask the user where to get the data","User strongly prefers API-driven development over mock/constant data","Do not start servers or open pages in browser unless explicitly asked by the user","User prefers manual control over when servers are started and browsers are opened","Only use server startup and browser opening when directly requested","Current date is 31 May 2025","Operating system is macOS","Default shell is zsh - generate terminal commands for zsh","Working in workspace: /Users/viktorfarcic/code/youtube-web","Project structure includes: app/ (Next.js), mock/ (mock server), tests/ (test files), screenshots/","Main app components: Header.tsx, PhaseFilterBar.tsx in src/app/components/","Test files organized by page: homepage.test.js, videos.test.js, create.test.js, edit.test.js","Mock server files: index.html, mockup.js, styles.css in mock/ directory","Test utilities in tests/utils/test-helpers.js","To stop development servers properly: 1) Use 'ps aux | grep -E \"(next|node|npm)\"' to find running processes, 2) Use 'pkill -f \"next-server\"' for Next.js dev server, 3) Use 'pkill -f \"node.*mock\"' for mock server, 4) Use 'lsof -ti:3000 | xargs kill' to kill processes on port 3000, 5) Use 'lsof -ti:8081 | xargs kill' to kill processes on port 8081, 6) Always verify with 'ps aux | grep -E \"(next|node|npm)\"' after stopping","If 'pkill -9 npm' fails, use more specific process targeting","Mock server typically runs on port 8081, Next.js dev server on port 3000","Check both processes and ports when stopping servers","ALWAYS check the OpenAPI schema from the backend (https://github.com/vfarcic/youtube-automation) before implementing API integrations","Use the OpenAPI schema to understand exact API endpoints, request/response structures, and data models","Do not assume API structure - always reference the authoritative OpenAPI specification first","CRITICAL SERVER STARTUP REMINDER: When user says 'start servers', ALWAYS open BOTH servers in browsers:","1. Start Next.js app (cd app && npm run dev) in background","2. Start mock server (cd mock && python3 -m http.server 8081) in background","3. Open main app: 'open http://localhost:3000'","4. Open mock server: 'open http://localhost:8081'","DO NOT forget step 4 - this was missed and user had to remind about opening the mock server","Both browsers should open automatically when starting servers - this is expected behavior","TESTING STRATEGY: Use Puppeteer for testing by default in this project","The project has a comprehensive Puppeteer-based integration testing framework","Existing test infrastructure covers: API connectivity, component behavior in browsers, network request monitoring, end-to-end functionality","DO NOT add Jest unit tests unless there's a specific need that can't be covered by Puppeteer integration tests","Focus on testing through the existing test framework in /tests/ directory","Puppeteer tests provide real browser environment testing which is more valuable for this web application","Only consider alternative testing approaches if Puppeteer cannot adequately test a specific scenario","CRITICAL SERVER STARTUP REMINDER: When user says 'start servers', ALWAYS open BOTH servers in browsers:\n1. Start Next.js app (cd app && npm run dev) in background\n2. Start mock server (cd mock && python3 -m http.server 8081) in background\n3. Open main app: 'open http://localhost:3000'\n4. Open mock server: 'open http://localhost:8081'\nDO NOT forget step 4 - this was missed and user had to remind about opening the mock server\nBoth browsers should open automatically when starting servers - this is expected behavior","Assume that both the app and the mock are running when testing with Playwright","Do not use playwright navigation tools for opening servers in browsers during startup"]}
{"type":"entity","name":"Memory MCP Usage Restriction","entityType":"development_guideline","observations":["Do NOT use memory MCP to store information unless explicitly instructed by the user to memorize something","Memory MCP should only be used when user specifically requests to store information","Do not use memory MCP for internal decision-making about what to remember","Only use memory MCP tools (f1e_create_entities, f1e_add_observations, etc.) when explicitly asked by user"]}
{"type":"entity","name":"YouTube Web App Test Completion Workflow","entityType":"automation_workflow","observations":["Triggered by completion phrases: 'we are done', 'that's it', 'finished', 'complete', 'wrap this up'","Step 1: Run all tests using 'cd app && npm test'","Step 2: Stop any running development servers and background processes","Step 3: Show files to be pushed for user review before proceeding","Step 4: Create a new descriptive branch name","Step 5: Add and commit all modified/created files","Step 6: Push to GitHub and create PR","Step 7: Merge the PR after successful push","Must identify files that were created or modified during session","Current session files: tests/test-runner.js, app/package.json, run-tests.js, SPEED-OPTIMIZATION-GUIDE.md","Always preview files before pushing for user approval","Step 0 (NEW): Update README.md with latest project evaluation and current state","README updates should happen BEFORE starting git operations","README should reflect actual project structure, features, and current development status","Remove aspirational language and focus on implemented functionality","Include accurate technology versions, test metrics, and installation instructions","After merging the Pull Request, delete the remote feature branch.","After deleting the remote feature branch, delete the local feature branch.","After deleting the local feature branch, commit the memory.json file.","After deleting the local feature branch, switch to the main branch and pull the latest changes.","Commit the memory.json file to the main branch with a message like 'docs: Update workflow memory after project finalization'.","Push the main branch with the updated memory.json.","Step 3.5 (CLEANUP): Execute temporary file cleanup before git operations","Delete all Taskmaster task files: 'rm -rf tasks/*' (files are in .gitignore)","Delete any temporary PRD files: 'rm -f scripts/prd_*.txt scripts/prd_*.md'","This cleanup happens AFTER tests pass but BEFORE git branch creation","Cleanup is mandatory - these files should never be committed to repository","Updated workflow order: Test → Stop servers → Cleanup → Git operations → PR → Merge"]}
{"type":"entity","entityType":"development_guideline","name":"Core Development Practices","observations":["CRITICAL: Always examine existing CSS files and styling patterns before adding new styles","NEVER use inline styles or CSS-in-JS unless absolutely necessary - use separate CSS files or existing styling methodology","Always reuse existing component patterns and CSS classes before creating new ones","Check globals.css, component CSS files, and mock/styles.css to understand the existing design system","Maintain visual consistency with existing components when implementing new features","Follow the project's established CSS architecture and naming conventions","Only create new styles when existing ones cannot be extended or reused","Separate styling concerns from component logic for better maintainability","TESTING: Follow the Consolidated Test Strategy for focused testing during development and comprehensive testing at task completion","Use focused tests (npm test -- --page=X) during development, full tests (npm test) before marking tasks done","Always run tests after code changes to verify nothing is broken"]}
{"type":"entity","entityType":"instruction_preference","name":"Testing Preferences","observations":["Use Playwright screenshots actively for debugging and visual verification","Screenshots provide essential visual confirmation when debugging UI problems"]}
{"type":"entity","entityType":"development_guideline","name":"Test Failure Debugging","observations":["When tests fail, use Playwright MCP to gather more info including screenshots to visually analyze the issue","Screenshots help identify visual problems that text-based debugging might miss"]}
{"type":"entity","name":"Data Source Guidelines","entityType":"Development Practice","observations":["Hard-coded data should have clear naming indicating it's mock/fallback data","Variables containing static data should use names like 'mockPhaseNames' or 'fallbackPhaseNames' to clearly indicate they are not from API","This helps distinguish between temporary mock data and actual API integration"]}
{"type":"entity","name":"TDD Development Methodology","entityType":"development_guideline","observations":["Always follow Test-Driven Development (TDD) principles for new feature development","TDD Cycle: Red (write failing test first) → Green (minimal code to pass) → Refactor (improve while keeping tests passing)","Write tests BEFORE implementing functionality, not after","Tests should drive the design and architecture of the code","Each test should be small, focused, and test a single behavior","Never write production code without a failing test first","Tests serve as living documentation and specification","Use TDD to ensure high code quality, better design, and regression prevention","TDD promotes incremental development with immediate feedback","Refactor confidently knowing tests will catch any breaking changes"]}
{"type":"entity","name":"PRD Management Guidelines","entityType":"development_guideline","observations":["Product Requirement Documents (PRDs) are GitHub Issues labeled with 'PRD'","PRDs serve as single source of truth - avoid duplicating content in local files","If tools require file input, create ephemeral files from GitHub Issue content, use immediately, then delete","LESSON LEARNED: When API endpoints are missing, immediately create GitHub Issues for PRDs instead of creating local files first","Always clean up temporary PRD files after creating GitHub Issues - local PRD files are temporary and should not persist","Follow the established workflow: Missing API → Direct GitHub Issue creation with 'PRD' label → Clean up any temporary files","Avoid the anti-pattern of: Local PRD file → GitHub Issue → Forgetting to clean up local file","PRDs must live in GitHub Issues as the single source of truth, not duplicated in local files","CRITICAL: When creating GitHub Issues for PRDs, ALWAYS add the 'PRD' label to properly categorize and track product requirements","GitHub Issues serving as PRDs must be labeled with 'PRD' for proper project management and visibility","PRD label addition is mandatory step in GitHub Issue creation workflow for requirements documentation","Use `gh issue list --label PRD` to fetch PRDs","Use `gh issue view <number>` to view specific PRD details","When creating new PRDs, use `gh issue create --label PRD` to create issues with PRD label"]}
{"type":"entity","name":"PRD Workflow Process","entityType":"development_workflow","observations":["MUST use Taskmaster to generate tasks from PRD before implementation begins","When starting work on PRD, add comment to GitHub Issue: 'Work started on this PRD on YYYY-MM-DD. Tasks have been generated in the local Taskmaster setup.'","When Taskmaster tasks are complete, close the original PRD GitHub Issue","Follow TDD principles - write tests before implementation","Record baseline test coverage before starting any feature work","All tests must pass before marking Taskmaster tasks as 'done'","PRDs must specify mock-first development approach: Design and prototype new features as mock first, then move to app implementation","App development (not mock) MUST follow TDD principles - write tests before implementing functionality","TDD cycle for app development: Red (write failing test) → Green (minimal code to pass) → Refactor (improve while keeping tests passing)","Mock development does NOT require TDD - mocks are for rapid prototyping and design validation","App implementation must be test-driven with comprehensive test coverage before marking tasks complete","Use `gh issue comment <number>` to update PRD status and add progress comments"]}
{"type":"entity","name":"PRD File Handling","entityType":"development_guideline","observations":["PRD text files (prd_*.txt, prd_*.md) in scripts/ directory are temporary","These files should NOT be committed to Git repository","Add patterns like 'scripts/prd_*.txt' and 'scripts/prd_*.md' to .gitignore","Use parse_prd command only for initial ingestion of new file-based PRDs not yet in GitHub Issues","Prefer working directly from GitHub Issues over local PRD files"]}
{"type":"entity","name":"PRD Pull Request Workflow","entityType":"development_workflow","observations":["PR description MUST include direct link to originating PRD GitHub Issue","Remove all Taskmaster task files (tasks/tasks.json and tasks/*.md) when creating PR","Use 'rm -rf tasks/*' to clean up task directory (files are in .gitignore)","Add list of completed Taskmaster tasks to PR description with task IDs and titles","Mark tasks as 'done' in PR description for clear tracking","This cleanup is local filesystem change, not staged git rm due to .gitignore"]}
{"type":"entity","name":"PRD Communication Guidelines","entityType":"development_guideline","observations":["When presenting user with choices, format as numbered list for easy selection","Local Git operations (commit, push, branch) should use git CLI commands","Use `gh` CLI as primary method for all GitHub operations","GitHub MCP has been removed, so all GitHub operations must use terminal commands with `gh` CLI"]}
{"type":"entity","name":"Memory Usage Protocol","entityType":"behavioral_rule","observations":["User explicitly instructed: Never write anything into memory MCP without the user asking me to do so","I must wait for explicit user request before creating, updating, or modifying any memory entries","This is a strict behavioral constraint that overrides any automatic memory logging impulses","Memory operations should only be performed when the user specifically requests them","This rule applies to all memory MCP functions: create_entities, add_observations, create_relations, etc."]}
{"type":"entity","name":"Playwright MCP Integration","entityType":"development_tool","observations":["Playwright is available as an MCP (Model Context Protocol) server in this environment","No separate installation of Playwright is required - it can be used directly through MCP tools","Available Playwright MCP tools include: browser resize, console messages, dialog handling, browser close","Should not suggest installing Playwright when it's already available via MCP","Playwright MCP provides browser automation capabilities for testing and debugging"]}
{"type":"entity","name":"Playwright Visual Comparison Workflow","entityType":"development_process","observations":["Use Playwright browser automation to take screenshots of both mock designs and live app for visual comparison","Compare mock/index.html with app running on localhost:3000 to ensure design consistency","Take screenshots at same viewport sizes and elements for accurate comparison","Use this workflow when implementing UI components to verify they match the original design","Screenshots help identify visual discrepancies between intended design and actual implementation","Particularly useful for form styling, button designs, layouts, colors, and spacing verification"]}
{"type":"entity","name":"Mock Design Location","entityType":"file_location","observations":["Mock design HTML file located at: mock/index.html","Mock CSS styles located at: mock/styles.css","Mock contains the reference design that the app should match visually","Use file:// protocol to open mock/index.html in Playwright browser for screenshots"]}
{"type":"entity","name":"App Testing Location","entityType":"testing_environment","observations":["Live app runs on http://localhost:3000","Use specific URLs with parameters for testing forms (e.g., /videos?edit=85&video=85&aspect=definition)","Take screenshots of same UI components/views in both mock and app for comparison","Wait for components to fully load before taking screenshots for accurate comparison"]}
{"type":"entity","name":"Consolidated Test Strategy","entityType":"development_guideline","observations":["FOCUSED TESTING DURING DEVELOPMENT: Run specific page/feature tests while working on tasks for fast feedback","Use 'npm test -- --page=videos' for videos page development, 'npm test -- --page=homepage' for homepage work, etc.","Available focused test options: --page=videos, --page=homepage, --page=aspect-selection, --page=aspect-edit-form, --page=aspect-progress-tracking, --page=create","Use 'npm test -- --integration' to run only backend connectivity and API tests during API work","Use 'npm test -- --ui' to run only UI/page tests when working on frontend components","COMPREHENSIVE TESTING AT TASK COMPLETION: Run full test suite before marking tasks as 'done'","Use 'npm test' (no flags) to run all tests when finishing a task to ensure no regressions","Full test suite validates: UI functionality, API integration, backend connectivity, data validation (including PRD requirements)","MODERN TEST ARCHITECTURE: Single consolidated test runner at tests/test-runner.js","Tests organized by page/feature: tests/pages/ for UI tests, tests/integration/ for API tests","String-based ID validation (PRD #18) integrated into videos page test where data is actually used","No redundant test files - each feature tested in its logical location","TEST-DRIVEN DEVELOPMENT: Write failing tests first, then implement minimal code to pass","TDD cycle: Red (failing test) → Green (minimal implementation) → Refactor (improve while tests pass)","Use focused testing during TDD iterations for rapid feedback loops","PERFORMANCE: Focused tests run in ~2-3 seconds, full suite in ~20-25 seconds","Fast feedback enables productive TDD cycles and efficient development workflow"]}
{"type":"entity","name":"Taskmaster Task Structure Format","entityType":"development_guideline","observations":["TASK ID FORMAT: Top-level tasks use simple integers: 1, 2, 3, etc.","SUBTASK ID FORMAT: Subtasks use simple sequential integers: 1, 2, 3, etc. (NOT dot notation)","INCORRECT: Subtask IDs like '17.1', '17.2' - these are display conventions, not actual ID values","CORRECT: Subtask IDs should be 1, 2, 3 within each parent task","The dot notation (17.1, 17.2) is only for display/reference purposes when showing task relationships","JSON structure: parent task has 'subtasks' array where each subtask has simple integer 'id' field","Example: Task 17 with subtasks should have subtask IDs: 1, 2, 3 (not 17.1, 17.2, 17.3)","When referencing subtasks in commands/tools, use format 'parentId.subtaskId' (e.g., '17.1') but actual stored ID is just the subtask number","This maintains clean data structure while allowing clear referencing in user interfaces and commands"]}
{"type":"relation","from":"YouTube Web App Test Completion Workflow","to":"Viktor Farcic","relationType":"executes workflow for"}
{"type":"relation","from":"PRD Management Guidelines","to":"MCP Tool Usage Guidelines","relationType":"extends"}
{"type":"relation","from":"PRD Workflow Process","to":"TDD Development Methodology","relationType":"implements"}
{"type":"relation","from":"PRD Pull Request Workflow","to":"YouTube Web App Test Completion Workflow","relationType":"complements"}
{"type":"relation","from":"PRD File Handling","to":"Development Guidelines","relationType":"extends"}